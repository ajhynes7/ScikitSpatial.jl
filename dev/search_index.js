var documenterSearchIndex = {"docs":
[{"location":"types/plane/#Plane","page":"Plane","title":"Plane","text":"","category":"section"},{"location":"types/plane/","page":"Plane","title":"Plane","text":"A plane is defined by a point and a normal vector.","category":"page"},{"location":"types/plane/","page":"Plane","title":"Plane","text":"julia> using ScikitSpatial\n\njulia> plane = Plane([0, 0, 0], [0, 0, 1])\nPlane{3, Int64}([0, 0, 0], [0, 0, 1])\n\njulia> plane.point\n3-element StaticArrays.SVector{3, Int64} with indices SOneTo(3):\n 0\n 0\n 0\n\njulia> plane.vector\n3-element StaticArrays.SVector{3, Int64} with indices SOneTo(3):\n 0\n 0\n 1","category":"page"},{"location":"types/plane/","page":"Plane","title":"Plane","text":"The normal vector can also be accessed with the normal field.","category":"page"},{"location":"types/plane/","page":"Plane","title":"Plane","text":"julia> plane.normal\n3-element StaticArrays.SVector{3, Int64} with indices SOneTo(3):\n 0\n 0\n 1","category":"page"},{"location":"computations/measurement/#Measurement","page":"Measurement","title":"Measurement","text":"","category":"section"},{"location":"computations/measurement/","page":"Measurement","title":"Measurement","text":"cosine_similarity\nangle_between\ndistance","category":"page"},{"location":"computations/measurement/#ScikitSpatial.cosine_similarity","page":"Measurement","title":"ScikitSpatial.cosine_similarity","text":"cosine_similarity(u::AbstractVector, v::AbstractVector) -> Float\n\nCompute the cosine similarity of two vectors.\n\nExamples\n\njulia> cosine_similarity([1, 0], [1, 0])\n1.0\n\njulia> round(cosine_similarity([1,1], [1,0]), digits=3)\n0.707\n\njulia> cosine_similarity([1, 0], [0, 1])\n0.0\n\njulia> cosine_similarity([-1, 0], [1, 0])\n-1.0\n\njulia> round(cosine_similarity([1,0,0], [1,1,1]), digits=3)\n0.577\n\n\n\n\n\n","category":"function"},{"location":"computations/measurement/#ScikitSpatial.angle_between","page":"Measurement","title":"ScikitSpatial.angle_between","text":"angle_between(u::AbstractVector, v::AbstractVector) -> Float\n\nCompute the angle between two vectors. The angle is returned in radians.\n\nExamples\n\njulia> angle_between([1, 0], [1, 0])\n0.0\n\njulia> round(angle_between([1,1], [1,0]), digits=3)\n0.785\n\njulia> round(angle_between([1, 0], [0, 1]), digits=3)\n1.571\n\njulia> round(angle_between([-1, 0], [1, 0]), digits=3)\n3.142\n\njulia> round(angle_between([1,0,0], [1,1,1]), digits=3)\n0.955\n\n\n\n\n\n","category":"function"},{"location":"computations/measurement/#ScikitSpatial.distance","page":"Measurement","title":"ScikitSpatial.distance","text":"distance(point_a::AbstractVector, point_b::AbstractVector) -> Float\n\nCompute the distance between two points.\n\nExamples\n\njulia> distance([0, 0], [0, 0])\n0.0\n\njulia> distance([1, 0], [0, 0])\n1.0\n\njulia> round(distance([1, 1], [2, 2]), digits=3)\n1.414\n\njulia> round(distance([0, 0, 0], [-1, -1, -1]), digits=3)\n1.732\n\n\n\n\n\ndistance(point_a::AbstractVector, point_b::AbstractVector) -> Float\n\nCompute the distance from a point to a line.\n\nThis is the distance from the point to its projection on the line.\n\nExamples\n\njulia> distance([0, 0], Line([0, 0], [1, 0]))\n0.0\n\njulia> round(distance([1, 0], Line([0, 0], [1, 1])), digits=3)\n0.707\n\njulia> round(distance([1, 2, 3], Line([-1, 3, 2], [7, 4, 2])), digits=3)\n1.978\n\n\n\n\n\n","category":"function"},{"location":"types/line/#Line","page":"Line","title":"Line","text":"","category":"section"},{"location":"types/line/","page":"Line","title":"Line","text":"A line is defined by a point and a direction vector.","category":"page"},{"location":"types/line/","page":"Line","title":"Line","text":"julia> using ScikitSpatial\n\njulia> line = Line([0, 0], [1, 0])\nLine{2, Int64}([0, 0], [1, 0])\n\njulia> line.point\n2-element StaticArrays.SVector{2, Int64} with indices SOneTo(2):\n 0\n 0\n\njulia> line.vector\n2-element StaticArrays.SVector{2, Int64} with indices SOneTo(2):\n 1\n 0","category":"page"},{"location":"types/line/","page":"Line","title":"Line","text":"The direction vector can also be accessed with the direction field.","category":"page"},{"location":"types/line/","page":"Line","title":"Line","text":"julia> line.direction\n2-element StaticArrays.SVector{2, Int64} with indices SOneTo(2):\n 1\n 0","category":"page"},{"location":"computations/intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"computations/intersection/","page":"Intersection","title":"Intersection","text":"intersect","category":"page"},{"location":"computations/intersection/#Base.intersect","page":"Intersection","title":"Base.intersect","text":"intersect(line_a::AbstractLine, line_b::AbstractLine) -> AbstractVector\n\nCompute the intersection of two lines.\n\nThe intersection of two lines is a point.\n\nExamples\n\njulia> intersect(Line([0, 0], [1, 0]), Line([5, 5], [0, 1]))\n2-element StaticArrays.SVector{2, Float64} with indices SOneTo(2):\n 5.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"computations/comparison/#Comparison","page":"Comparison","title":"Comparison","text":"","category":"section"},{"location":"computations/comparison/","page":"Comparison","title":"Comparison","text":"is_zero\nare_parallel\nare_perpendicular","category":"page"},{"location":"computations/comparison/#ScikitSpatial.is_zero","page":"Comparison","title":"ScikitSpatial.is_zero","text":"is_zero(v; kwargs...)\n\nCheck if a vector is the zero vector.\n\nThis function checks if the dot product of the vector with itself is approximately zero. Keyword arguments can be passed along to isapprox.\n\nExamples\n\njulia> is_zero([0, 0])\ntrue\n\njulia> is_zero([1, 0])\nfalse\n\njulia> is_zero([0, 1e-3])\nfalse\n\njulia> is_zero([0, 1e-3], atol=1e-2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"computations/comparison/#ScikitSpatial.are_parallel","page":"Comparison","title":"ScikitSpatial.are_parallel","text":"are_parallel(u, v; kwargs...) -> Bool\n\nCheck if two vectors are parallel.\n\nTwo nonzero vectors u and v are parallel if\n\nlvert textttcosine_similarity(u v) rvert = 0\n\nThe zero vector is considered to be parallel to all vectors.\n\nKeyword arguments can be passed along to isapprox. The tolerances are used to check if the vector is zero, or if the vectors are otherwise parallel.\n\nExamples\n\njulia> are_parallel([1, 0], [1, 0])\ntrue\n\njulia> are_parallel([1, 0], [5, 0])\ntrue\n\njulia> are_parallel([1, 0], [-5, 0])\ntrue\n\njulia> are_parallel([5, 3], [-10, -6])\ntrue\n\njulia> are_parallel([5, 3], [-10, 6])\nfalse\n\nThe zero vector is considered to be parallel to all vectors.\n\njulia> are_parallel([0, 0], [1, 1])\ntrue\n\njulia> are_parallel([1, 1], [0, 0])\ntrue\n\nThe tolerances are used to check if the vector is zero, or if the vectors are otherwise parallel.\n\njulia> are_parallel([1, 1], [0, 1e-3])\nfalse\n\njulia> are_parallel([1, 1], [0, 1e-3], atol=1e-2)\ntrue\n\njulia> are_parallel([1, 1], [1, 1.01])\nfalse\n\njulia> are_parallel([1, 1], [1, 1.01], atol=1e-2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"computations/comparison/#ScikitSpatial.are_perpendicular","page":"Comparison","title":"ScikitSpatial.are_perpendicular","text":"are_perpendicular(u, v; kwargs...) -> Bool\n\nCheck if two vectors are perpendicular.\n\nTwo vectors u and v are perpendicular if\n\nu cdot v = 0\n\nKeyword arguments can be passed along to isapprox.\n\n\n\n\n\n","category":"function"},{"location":"#ScikitSpatial.jl","page":"Introduction","title":"ScikitSpatial.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the ScikitSpatial.jl documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ScikitSpatial.jl provides types representing spatial entities, as well as functions for computations between them.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following types are provided:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Line\nPlane\nCircle\nSphere","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Most of the computations fall into the following categories:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Measurement\nComparison\nProjection\nIntersection\nTransformation","category":"page"},{"location":"computations/projection/#Projection","page":"Projection","title":"Projection","text":"","category":"section"},{"location":"computations/projection/","page":"Projection","title":"Projection","text":"project","category":"page"},{"location":"computations/projection/#ScikitSpatial.project","page":"Projection","title":"ScikitSpatial.project","text":"project(u::AbstractVector, v::AbstractVector) -> AbstractVector\n\nProject vector u onto vector v.\n\nExamples\n\njulia> project([1, 1], [1, 0])\n2-element Base.Vector{Float64}:\n 1.0\n 0.0\n\njulia> project([5, 5], [1, 0])\n2-element Base.Vector{Float64}:\n 5.0\n 0.0\n\njulia> project([5, -5], [0, 1])\n2-element Base.Vector{Float64}:\n -0.0\n -5.0\n\n\n\n\n\nproject(point::AbstractVector, line::AbstractLine) -> StaticArrays.SVector\n\nProject a point onto a line.\n\nExamples\n\njulia> project([1, 1], Line([0, 0], [1, 0]))\n2-element StaticArrays.SVector{2, Float64} with indices SOneTo(2):\n 1.0\n 0.0\n\njulia> project([5, -1], Line([0, 0], [1, 0]))\n2-element StaticArrays.SVector{2, Float64} with indices SOneTo(2):\n 5.0\n 0.0\n\njulia> project([1, 0], Line([0, 0], [1, 1]))\n2-element StaticArrays.SVector{2, Float64} with indices SOneTo(2):\n 0.5\n 0.5\n\njulia> point = project([1, 0, 0], Line([0, 0, 0], [1, 1, 1]));\n\njulia> round.(point, digits=3)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 0.333\n 0.333\n 0.333\n\n\n\n\n\nproject(point::AbstractVector, plane::AbstractPlane) -> StaticArrays.SVector\n\nProject a point onto a plane.\n\nExamples\n\njulia> project([0, 0, 5], Plane([0, 0, 0], [0, 0, 1]))\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 0.0\n 0.0\n 0.0\n\njulia> plane = Plane([1,2,3], [1, 3, -2]);\n\njulia> point_projected = project([5, 1, 3], plane);\n\njulia> round.(point_projected, digits=3)\n3-element StaticArrays.SVector{3, Float64} with indices SOneTo(3):\n 4.929\n 0.786\n 3.143\n\n\n\n\n\n","category":"function"},{"location":"computations/transformation/#Transformation","page":"Transformation","title":"Transformation","text":"","category":"section"},{"location":"computations/transformation/","page":"Transformation","title":"Transformation","text":"ScikitSpatial.Vector\nunit\nto_point\ncentroid\nmean_center","category":"page"},{"location":"computations/transformation/#ScikitSpatial.Vector","page":"Transformation","title":"ScikitSpatial.Vector","text":"Vector(point_a::AbstractVector, point_b::AbstractVector) -> AbstractVector\n\nReturn the vector from point A to point B.\n\nExamples\n\njulia> import ScikitSpatial: Vector\n\njulia> Vector([0, 0], [1, 1])\n2-element Base.Vector{Int64}:\n 1\n 1\n\njulia> Vector([-1, 0], [1, 1])\n2-element Base.Vector{Int64}:\n 2\n 1\n\njulia> Vector([5, 2, -4], [3, -1, 9])\n3-element Base.Vector{Int64}:\n -2\n -3\n 13\n\n\n\n\n\n","category":"function"},{"location":"computations/transformation/#ScikitSpatial.unit","page":"Transformation","title":"ScikitSpatial.unit","text":"unit(v::AbstractVector) -> AbstractVector\n\nReturn the unit vector in the same direction as the input vector.\n\nExamples\n\njulia> unit([2, 0])\n2-element Base.Vector{Float64}:\n 1.0\n 0.0\n\njulia> round.(unit([1, 1]), digits=3)\n2-element Base.Vector{Float64}:\n 0.707\n 0.707\n\njulia> round.(unit([1, 1]), digits=3)\n2-element Base.Vector{Float64}:\n 0.707\n 0.707\n\njulia> round.(unit([-1, 1, -3]), digits=3)\n3-element Base.Vector{Float64}:\n -0.302\n  0.302\n -0.905\n\n\n\n\n\n","category":"function"},{"location":"computations/transformation/#ScikitSpatial.to_point","page":"Transformation","title":"ScikitSpatial.to_point","text":"to_point(line::AbstractLine, t::Int=1) -> AbstractVector\n\nReturn a point along the line.\n\nExamples\n\njulia> line = Line([1, 3], [2, -5]);\n\njulia> to_point(line)\n2-element StaticArrays.SVector{2, Int64} with indices SOneTo(2):\n  3\n -2\n\n\n\n\n\n","category":"function"},{"location":"computations/transformation/#ScikitSpatial.centroid","page":"Transformation","title":"ScikitSpatial.centroid","text":"centroid(points::AbstractMatrix) -> AbstractVector\n\nCompute the centroid of multiple points.\n\nThe points are represented by a D x N array, where D is the number of dimensions and N is the number of points.\n\nExamples\n\njulia> point_a = [-1, -1]; point_b = [0, 0]; point_c = [1, 1];\n\njulia> points = hcat(point_a, point_b, point_c)\n2×3 Matrix{Int64}:\n -1  0  1\n -1  0  1\n\njulia> centroid(points)\n2-element Base.Vector{Float64}:\n 0.0\n 0.0\n\njulia> point_a = [5, -3, 2]; point_b = [2, 1, 3]; point_c = [8, 1, 9]; point_d = [2, 3, 3];\n\njulia> points = hcat(point_a, point_b, point_c, point_d)\n3×4 Matrix{Int64}:\n  5  2  8  2\n -3  1  1  3\n  2  3  9  3\n\njulia> centroid(points)\n3-element Base.Vector{Float64}:\n 4.25\n 0.5\n 4.25\n\n\n\n\n\n","category":"function"},{"location":"computations/transformation/#ScikitSpatial.mean_center","page":"Transformation","title":"ScikitSpatial.mean_center","text":"mean_center(points::AbstractMatrix) -> AbstractVector\n\nReturn a transformed set of points which are centered about the origin.\n\nThe centroid of the original points is treated as the origin for the new points.\n\nExamples\n\njulia> point_a = [5, 5]; point_b = [7, 7]; point_c = [9, 9];\n\njulia> points = hcat(point_a, point_b, point_c)\n2×3 Matrix{Int64}:\n 5  7  9\n 5  7  9\n\njulia> mean_center(points)\n2×3 Matrix{Float64}:\n -2.0  0.0  2.0\n -2.0  0.0  2.0\n\n\n\n\n\n","category":"function"}]
}
